******************************************************************************************************
//3种递归：
******************************************************************************************************
//前序：
void preOrder(TreeNode* root){
        if(root == NULL){
            return;
        }
        cout<<root->val;
        preOrder(root.left);
        preOrder(root.right);
}
******************************************************************************************************
//中序：
void inOrder(TreeNode* root){
        if(root == NULL){
            return;
        }
        inOrder(root.left);
        cout<<root->val;
        inOrder(root.right);
}
******************************************************************************************************
//后序：
void postOrder(TreeNode* root){
        if(root == NULL){
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        cout<<root->val;
}
******************************************************************************************************
//3种非递归：
******************************************************************************************************
//前序：
void preOrder(TreeNode* root){
	if(root==NULL){
		return;
	}
	stack<TreeNode*> s;
	auto temp=root;
	s.push(temp);
	while(!s.empty()){
		temp=s.top();
		cout<<temp->val<<' ';
		s.pop();
		if(temp->right){
			s.push(temp->right);
		}
		if(temp->left){
			s.push(temp->left);
		}
	}
}
******************************************************************************************************
//中序：
void inOrder(TreeNode* root){
	if(root==NULL){
		return;
	}
	stack<TreeNode*> s;
	auto temp=root;
	while(temp||!s.empty()){
		while(temp){
			s.push(temp);
			temp=temp->left;
		}
		if(!s.empty())
		{
			temp=s.top();
			s.pop();
			cout<<temp->val<<' ';
			temp=temp->right;
		}
	}
}
******************************************************************************************************
//后序：
void postOrder(TreeNode* root){
	stack<TreeNode*> s;
	TreeNode* temp = root;
	TreeNode* lastVisit =NULL;   
	while( temp!=NULL || !s.empty()){
		while( temp!=NULL){
			s.push( temp);
			temp=temp->left;
		}
		if(!s.empty()){
			 temp = s.top();
			 s.pop();
			if( temp->right == NULL ||  temp->right == lastVisit) {
				cout<<temp->val<<' ';
				lastVisit =  temp;
				 temp  = NULL;
			}else{
				s.push( temp);
				 temp =  temp->right;
			}
		}
    }
}
******************************************************************************************************
//层序遍历：
void levelOrder(TreeNode* root){
	queue<TreeNode*> q;
	q.push(root);
	while(!q.empty()){
		TreeNode* temp=q.front();
		cout<<temp->val<<' ';
		q.pop();
		if(temp->left){
			q.push(temp->left);
		}
		if(temp->right){
			q.push(temp->right);
		}
	}
}
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
#include<stack>
#include<queue>

using namespace std;

struct TreeNode{
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x): val(x),left(NULL),right(NULL){};
};


void preOrder(TreeNode* root){
	if(root==NULL){
		return;
	}
	stack<TreeNode*> s;
	auto temp=root;
	s.push(temp);
	while(!s.empty()){
		temp=s.top();
		cout<<temp->val<<' ';
		s.pop();
		if(temp->right){
			s.push(temp->right);
		}
		if(temp->left){
			s.push(temp->left);
		}
	}
}
void inOrder(TreeNode* root){
	if(root==NULL){
		return;
	}
	stack<TreeNode*> s;
	auto temp=root;
	while(temp||!s.empty()){
		while(temp){
			s.push(temp);
			temp=temp->left;
		}
		if(!s.empty())
		{
			temp=s.top();
			s.pop();
			cout<<temp->val<<' ';
			temp=temp->right;
		}
	}
}
void postOrder(TreeNode* root){
	stack<TreeNode*> s;
	TreeNode* temp = root;
	TreeNode* lastVisit =NULL;   
	while( temp!=NULL || !s.empty()){
		while( temp!=NULL){
			s.push( temp);
			temp=temp->left;
		}
		if(!s.empty()){
			 temp = s.top();
			 s.pop();
			if( temp->right == NULL ||  temp->right == lastVisit) {
				cout<<temp->val<<' ';
				lastVisit =  temp;
				 temp  = NULL;
			}else{
				s.push( temp);
				 temp =  temp->right;
			}
		}
    }
}

void levelOrder(TreeNode* root){
	queue<TreeNode*> q;
	q.push(root);
	while(!q.empty()){
		TreeNode* temp=q.front();
		cout<<temp->val<<' ';
		q.pop();
		if(temp->left){
			q.push(temp->left);
		}
		if(temp->right){
			q.push(temp->right);
		}
	}
}

int main(){
	TreeNode* h1=new TreeNode(1);
	TreeNode* h2=new TreeNode(2);
	TreeNode* h3=new TreeNode(3);
	TreeNode* h4=new TreeNode(4);
	TreeNode* h5=new TreeNode(5);
	TreeNode* h6=new TreeNode(6);
	TreeNode* h7=new TreeNode(7);
	
	h1->left=h2;
	h1->right=h3;
	h2->left=h4;
	h2->right=h5;
	h3->left=h6;
	h3->right=h7;

	levelOrder(h1);
	return 0;
}
